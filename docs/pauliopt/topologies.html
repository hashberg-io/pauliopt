<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>pauliopt.topologies API documentation</title>
<meta name="description" content="This module contains utility code to deal with qubit topologies." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pauliopt.topologies</code></h1>
</header>
<section id="section-intro">
<p>This module contains utility code to deal with qubit topologies.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
    This module contains utility code to deal with qubit topologies.
&#34;&#34;&#34;

import re
from typing import (Collection, Final, FrozenSet, Iterator, List, Optional,
                    Set, Tuple, TypedDict, Union)
import numpy as np # type: ignore

class Coupling(FrozenSet[int]):
    &#34;&#34;&#34;
        Type for couplings in a qubit topology, i.e. unordered
        pairs of adjacent qubits.
    &#34;&#34;&#34;
    def __new__(cls, fst: int, snd: int):
        if not isinstance(fst, int):
            raise TypeError(f&#34;Expected integer, found {fst}&#34;)
        if not isinstance(snd, int):
            raise TypeError(f&#34;Expected integer, found {snd}&#34;)
        if len({fst, snd}) != 2:
            raise ValueError(&#34;Expected a pair of distinct qubits.&#34;)
        # see https://github.com/python/mypy/issues/6061
        return super(Coupling, cls).__new__(cls, {fst, snd}) # type: ignore

    @property
    def as_pair(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
            Returns the coupling as a (increasingly) ordered pair.
        &#34;&#34;&#34;
        return (min(*self), max(*self)) # pylint: disable = not-an-iterable

    def __str__(self) -&gt; str:
        fst, snd = sorted(self)
        return f&#34;{{{fst}, {snd}}}&#34;

    def __repr__(self) -&gt; str:
        fst, snd = sorted(self)
        return f&#34;Coupling({fst}, {snd})&#34;


CouplingLike = Collection[int]
&#34;&#34;&#34;
    Type alias for things that could be used to specify couplings,
    namely any collection of `int` (subject to additional restrictions).

    In an ideal world, this should be &#34;int collections of len 2&#34;,
    but static typing does not yet allow for such a constraint.
&#34;&#34;&#34;


def _validate_coupling(num_qubits: int, coupling_like: CouplingLike) -&gt; Coupling:
    # Assumes `qubits` was already validated.
    if not isinstance(coupling_like, Collection) or len(coupling_like) != 2:
        raise TypeError(f&#34;Expected a pair, found {coupling_like}.&#34;)
    fst, snd = coupling_like
    if not 0 &lt;= fst &lt; num_qubits:
        raise TypeError(f&#34;Invalid qubit {fst}.&#34;)
    if not 0 &lt;= snd &lt; num_qubits:
        raise TypeError(f&#34;Invalid qubit {snd}.&#34;)
    return Coupling(fst, snd)


class TopologyDict(TypedDict, total=True):
    &#34;&#34;&#34;
        The type of the dictionary returned by `Topology.as_dict`,
        suitable for JSON serialization.
    &#34;&#34;&#34;

    num_qubits: int
    &#34;&#34;&#34;
        Property exposing the number of qubits in the topology.
    &#34;&#34;&#34;

    couplings: List[List[int]]
    &#34;&#34;&#34;
        Property exposing the couplings between qubits in the topology.
    &#34;&#34;&#34;


Layouts: Final[Tuple[str, ...]] = (&#34;circular&#34;, &#34;kamada_kawai&#34;, &#34;random&#34;,
                                   &#34;shell&#34;, &#34;spring&#34;, &#34;spectral&#34;, &#34;spiral&#34;)
&#34;&#34;&#34;
    Possible layout values for `Topology.draw`
&#34;&#34;&#34;


def _floyd_warshall(topology: &#34;Topology&#34;) -&gt; np.ndarray:
    &#34;&#34;&#34;
        Runs the Floyd–Warshall to compute a matrix of distances between all pairs
        of qubits in a topology. Raises `ValueError` if topology is not connected.
    &#34;&#34;&#34;
    num_qubits = topology.num_qubits
    def init_dist(u, v):
        if u == v:
            return 0
        coupling = Coupling(u, v)
        if coupling in topology.couplings:
            return 1
        return num_qubits # a number surely larger than max dist in topology
    dist = np.zeros(shape=(num_qubits, num_qubits), dtype=np.uint32)
    for u in topology.qubits:
        for v in topology.qubits:
            dist[u, v] = init_dist(u, v)
    for w in topology.qubits:
        for u in topology.qubits:
            for v in topology.qubits:
                upper_bound = dist[u, w] + dist[w, v]
                if dist[u, v] &gt; upper_bound:
                    dist[u, v] = upper_bound
    for u in topology.qubits:
        for v in topology.qubits:
            if dist[u, v] == num_qubits:
                raise ValueError(&#34;Topology is not connected.&#34;)
    return dist


class Topology:
    &#34;&#34;&#34;
        Container class for a qubit topology.
    &#34;&#34;&#34;
    _num_qubits: int
    _couplings: FrozenSet[Coupling]
    _adjacent: Tuple[FrozenSet[int], ...]
    _dist: np.ndarray
    _named: Optional[str] = None

    def __init__(self, num_qubits: int, couplings: Collection[CouplingLike]):
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be a positive integer.&#34;)
        if not isinstance(couplings, Collection):
            raise TypeError(&#34;Couplings must be a collection of pairs of qubits.&#34;)
        self._num_qubits = num_qubits
        self._couplings = frozenset(_validate_coupling(num_qubits, c) for c in couplings)
        _adjacent: Tuple[Set[int], ...] = tuple(set() for _ in range(num_qubits))
        for fst, snd in self.couplings:
            _adjacent[fst].add(snd)
            _adjacent[snd].add(fst)
        self._adjacent = tuple(frozenset(n) for n in _adjacent)
        self._dist = _floyd_warshall(self)

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property returning the number of qubits in this topology.
        &#34;&#34;&#34;
        return self._num_qubits

    @property
    def qubits(self) -&gt; range:
        &#34;&#34;&#34;
            Readonly property returning the range of qubits in this topology.
        &#34;&#34;&#34;
        return range(self._num_qubits)

    @property
    def couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property exposing the couplings between qubits in this topology.
        &#34;&#34;&#34;
        return self._couplings

    @property
    def as_dict(self) -&gt; Union[str, TopologyDict]:
        &#34;&#34;&#34;
            Readonly property returning this topology as
            a dictionary, for serialization purposes.
        &#34;&#34;&#34;
        if self._named is not None:
            return self._named
        return {
            &#34;num_qubits&#34;: self.num_qubits,
            &#34;couplings&#34;: sorted(list(c.as_pair) for c in self.couplings)
        }

    @property
    def is_planar(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this qubit topology is a planar graph.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as e: # pylint: disable = unused-variable
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        G = self.to_nx
        is_planar, _ = nx.check_planarity(G)
        return is_planar

    @property
    def available_nx_layouts(self) -&gt; Tuple[str, ...]:
        &#34;&#34;&#34;
            Readonly property returning the available layouts for this qubit topology.
        &#34;&#34;&#34;
        if self.is_planar:
            return Layouts+(&#34;planar&#34;,)
        return Layouts

    @property
    def to_nx(self):
        &#34;&#34;&#34;
            Readonly property returning a NetworkX graph version of this topology.
            Requires the &#39;networkx&#39; library to work.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        g = nx.Graph()
        g.add_nodes_from(sorted(self.qubits))
        g.add_edges_from(sorted(self.couplings, key=lambda c: c.as_pair))
        return g

    def draw(self, layout: str = &#34;kamada_kawai&#34;, *,
             figsize: Optional[Tuple[int, int]] = None,
             **kwargs):
        &#34;&#34;&#34;
            Draws this qubit topology using NetworkX and Matplotlib.

            The `layout` keyword argument can be used to select a NetworkX layout
            from the available ones (exposed by `Topology.available_nx_layouts`).
            The `figsize` keyword argument is passed to `matplotlib.pyplot.figure`:
            if specified, it determines the width and height of the figure being drawn.
            Keyword arguments `kwargs` are those of `networkx.draw_networkx`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        try:
            # pylint: disable = import-outside-toplevel
            import matplotlib.pyplot as plt # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;matplotlib&#39; library.&#34;)
        G = self.to_nx
        kwargs = {**kwargs}
        layouts = self.available_nx_layouts
        if &#34;pos&#34; not in kwargs:
            if layout not in layouts:
                raise ValueError(f&#34;Invalid layout found: {layout}. &#34;
                                 f&#34;Valid layouts: {&#39;, &#39;.join(repr(l) for l in layouts)}&#34;)
            kwargs[&#34;pos&#34;] = getattr(nx, layout+&#34;_layout&#34;)(G)
        if &#34;node_color&#34; not in kwargs:
            kwargs[&#34;node_color&#34;] = &#34;#dddddd&#34;
        plt.figure(figsize=figsize)
        nx.draw_networkx(G, **kwargs)
        plt.show()

    def adjacent(self, qubit: int) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property exposing the (frozen) set of qubits adjacent
            to (i.e. couple with) the given qubit.
        &#34;&#34;&#34;
        if not isinstance(qubit, int):
            raise TypeError(&#34;Qubit should be an integer.&#34;)
        if qubit not in self:
            raise ValueError(f&#34;Invalid qubit {qubit}.&#34;)
        return self._adjacent[qubit]

    def incident(self, qubit: int) -&gt; Iterator[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning an iterator running over all couplings
            incident onto the given qubit.

            This is returned as an iterator, rather than a collection,
            because the couplings are generated on the fly (i.e. this is not
            merely exposing some internal collection).
        &#34;&#34;&#34;
        adjacent = self.adjacent(qubit)
        return (Coupling(qubit, q) for q in adjacent)

    def dist(self, fro: int, to: int) -&gt; int:
        &#34;&#34;&#34;
            Returns the distance between two given qubits in the topology.
        &#34;&#34;&#34;
        if not isinstance(fro, int) or fro not in self:
            raise TypeError(f&#34;Expected a valid qubit, found {fro}.&#34;)
        if not isinstance(to, int) or to not in self:
            raise TypeError(f&#34;Expected a valid qubit, found {to}.&#34;)
        return self._dist[fro, to]

    def __contains__(self, x: Union[int, Coupling, Tuple[int, int]]) -&gt; bool:
        if isinstance(x, int):
            return 0 &lt;= x &lt; self._num_qubits
        if isinstance(x, Coupling):
            return x in self._couplings
        if isinstance(x, tuple) and len(x) == 2:
            fst, snd = x
            if isinstance(fst, int) and isinstance(snd, int):
                return Coupling(fst, snd) in self
        raise TypeError(f&#34;Expected qubit or coupling, found {x}&#34;)

    def __repr__(self) -&gt; str:
        if self.couplings:
            return (f&#34;Topology({set(self.qubits)}, &#34;
                    f&#34;[{&#39;, &#39;.join(str(c) for c in self.couplings)}])&#34;)
        return f&#34;Topology({set(self.qubits)})&#34;

    def __hash__(self) -&gt; int:
        return hash((self.qubits, self.couplings))

    def __eq__(self, other) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Topology):
            return NotImplemented
        if self.qubits != other.qubits:
            return False
        if self.couplings != other.couplings:
            return False
        return True

    @staticmethod
    def from_dict(topology: Union[TopologyDict, str]) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a `Topology` instance from a dictionary in the
            format obtained from `Topology.as_dict`,
            for de-serialization purposes.
        &#34;&#34;&#34;
        if isinstance(topology, str):
            line_pattern = re.compile(r&#34;line\(([0-9]+)\)&#34;)
            if match := line_pattern.match(topology):
                return Topology.line(int(match[1]))
            cycle_pattern = re.compile(r&#34;cycle\(([0-9]+)\)&#34;)
            if match := cycle_pattern.match(topology):
                return Topology.cycle(int(match[1]))
            complete_pattern = re.compile(r&#34;complete\(([0-9]+)\)&#34;)
            if match := complete_pattern.match(topology):
                return Topology.complete(int(match[1]))
            grid_pattern = re.compile(r&#34;grid\(([0-9]+),([0-9]+)\)&#34;)
            if match := grid_pattern.match(topology):
                return Topology.grid(int(match[1]), int(match[2]))
            periodic_grid_pattern = re.compile(r&#34;periodic_grid\(([0-9]+),([0-9]+)\)&#34;)
            if match := periodic_grid_pattern.match(topology):
                return Topology.periodic_grid(int(match[1]), int(match[2]))
            raise ValueError(f&#34;Unexpected special topology {topology}&#34;)
        if &#34;num_qubits&#34; not in topology:
            raise TypeError(&#34;Expected key &#39;qubits&#39;.&#34;)
        if &#34;couplings&#34; not in topology:
            raise TypeError(&#34;Expected key &#39;couplings&#39;.&#34;)
        return Topology(topology[&#34;num_qubits&#34;], topology[&#34;couplings&#34;])

    @staticmethod
    def line(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a line topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, i+1] for i in range(num_qubits-1)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;line({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def cycle(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a cycle topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, (i+1)%num_qubits] for i in range(num_qubits)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;cycle({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def complete(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a complete topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, j] for i in range(num_qubits) for j in range(i+1, num_qubits)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;complete({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a grid topology with the given number of rows and cols.
            Qubits are indexed by rows.
        &#34;&#34;&#34;
        if not isinstance(num_rows, int) or num_rows &lt;= 0:
            raise TypeError(&#34;Number of rows must be positive integer.&#34;)
        if not isinstance(num_cols, int) or num_cols &lt;= 0:
            raise TypeError(&#34;Number of cols must be positive integer.&#34;)
        num_qubits = num_rows * num_cols
        def qubit(r, c):
            return num_cols*r + c
        couplings: List[List[int]] = []
        for r in range(num_rows):
            for c in range(num_cols):
                if r &lt; num_rows-1:
                    couplings.append([qubit(r, c), qubit(r+1, c)])
                if c &lt; num_cols-1:
                    couplings.append([qubit(r, c), qubit(r, c+1)])
        top = Topology(num_qubits, couplings)
        top._named = f&#34;grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def periodic_grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a periodic grid topology with the given number of rows and cols.
            Qubits are indexed by rows.
        &#34;&#34;&#34;
        if not isinstance(num_rows, int) or num_rows &lt;= 0:
            raise TypeError(&#34;Number of rows must be positive integer.&#34;)
        if not isinstance(num_cols, int) or num_cols &lt;= 0:
            raise TypeError(&#34;Number of cols must be positive integer.&#34;)
        num_qubits = num_rows * num_cols
        def qubit(r, c):
            return num_cols*r + c
        couplings: List[List[int]] = []
        for r in range(num_rows):
            for c in range(num_cols):
                couplings.append([qubit(r, c), qubit((r+1)%num_rows, c)])
                couplings.append([qubit(r, c), qubit(r, (c+1)%num_cols)])
        top = Topology(num_qubits, couplings)
        top._named = f&#34;periodic_grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def from_qiskit_config(config) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Static method to construct the topology from a
            Qiskit backend configuration.

            This method relies on the `qiskit` library being available.
            Specifically, the `config` argument must be of type
            `qiskit.providers.models.QasmBackendConfiguration`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.providers.models import QasmBackendConfiguration # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        if not isinstance(config, QasmBackendConfiguration):
            raise TypeError(&#34;Argument backend must be of type &#34;
                            &#34;`qiskit.providers.models.QasmBackendConfiguration`, &#34;
                            f&#34;found {type(config)}.&#34;)
        config_dict = config.to_dict()
        num_qubits: int = config_dict[&#34;n_qubits&#34;]
        coupling_map: List[List[int]] = config_dict[&#34;coupling_map&#34;]
        return Topology(num_qubits, coupling_map)

    @staticmethod
    def from_qiskit_backend(backend) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Static method to construct the topology from a Qiskit backend.

            This method relies on the `qiskit` library being available.
            Specifically, the `backend` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel, unused-import
            from qiskit.providers import BaseBackend # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        if not isinstance(backend, BaseBackend):
            raise TypeError(&#34;Argument backend must be of type &#34;
                            &#34;`qiskit.providers.BaseBackend`.&#34;)
        return Topology.from_qiskit_config(backend.configuration())


class Matching:
    &#34;&#34;&#34;
        Mutable container class for a matching on a qubit topology.
    &#34;&#34;&#34;

    _topology: Topology
    _matched_couplings: Set[Coupling]
    _matched_qubits: Set[int]
    _incident_coupling: List[Optional[Coupling]]

    def __init__(self, topology: Topology):
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {topology}.&#34;)
        self._topology = topology
        self._matched_couplings = set()
        self._matched_qubits = set()
        self._incident_coupling = [None for _ in topology.qubits]

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the qubit topology
            underlying this matching.
        &#34;&#34;&#34;
        return self._topology

    @property
    def matched_couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning the collection of couplings
            currently in this matching.

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._matched_couplings)

    @property
    def matched_qubits(self) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property returning the collection of qubits
            currently matched in this matching.

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._matched_qubits)

    @property
    def flippable_couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning the collection of couplings
            that can be currently flipped in this matching, namely:

            - all couplings currently in the matching (will be removed by flip);
            - all couplings with both qubits currently not matched by the matching
              (will be added by flip).

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._iter_flippable_couplings())

    def incident(self, qubit: int) -&gt; Optional[Coupling]:
        &#34;&#34;&#34;
            Returns the coupling incident to the given qubit in this matching,
            or `None` if the qubit is not matched.
        &#34;&#34;&#34;
        return self._incident_coupling[qubit]

    def is_flippable(self, coupling: CouplingLike) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the coupling can be flipped:

            - always true if the coupling is already present in the matching;
            - otherwise true only if neither qubit in the coupling is currently matched.
        &#34;&#34;&#34;
        coupling = _validate_coupling(self.topology.num_qubits, coupling)
        if coupling not in self.topology.couplings:
            raise ValueError(f&#34;Invalid coupling {coupling} for the given topology.&#34;)
        return self._is_flippable(coupling)

    def flip(self, coupling: CouplingLike) -&gt; &#34;Matching&#34;:
        &#34;&#34;&#34;
            Flips the given coupling in the matching (removes it if it is already present,
            adds it if it is not yed present and can be added).
            Raises `ValueError` if the coupling is not flippable.

            The matching is modified in-place and then returned, as per the
            [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
        &#34;&#34;&#34;
        coupling = _validate_coupling(self.topology.num_qubits, coupling)
        return self._flip(coupling)

    def _is_flippable(self, coupling: Coupling) -&gt; bool:
        if coupling in self._matched_couplings:
            return True
        fst, snd = coupling
        if fst in self._matched_qubits:
            return False
        if snd in self._matched_qubits:
            return False
        return True

    def _flip(self, coupling: Coupling) -&gt; &#34;Matching&#34;:
        if not self._is_flippable(coupling):
            raise ValueError(f&#34;Cannot add coupling {coupling} to matching:&#34;
                             f&#34;one of the qubits is already matched. &#34;)
        fst, snd = coupling
        if coupling in self._matched_couplings:
            self._matched_couplings.remove(coupling)
            self._matched_qubits.remove(fst)
            self._matched_qubits.remove(snd)
            self._incident_coupling[fst] = None
            self._incident_coupling[snd] = None
        else:
            self._matched_couplings.add(coupling)
            self._matched_qubits.add(fst)
            self._matched_qubits.add(snd)
            self._incident_coupling[fst] = coupling
            self._incident_coupling[snd] = coupling
        return self

    def _iter_flippable_couplings(self) -&gt; Iterator[Coupling]:
        for coupling in self._topology.couplings:
            fst, snd = coupling
            if coupling in self._matched_couplings:
                yield coupling
            elif fst not in self._matched_qubits and snd not in self._matched_qubits:
                yield coupling
            else:
                # coupling is not flippable
                pass</code></pre>
</details>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-variables">Global variables</h2>
<dl>
<dt id="pauliopt.topologies.CouplingLike"><code class="name">var <span class="ident">CouplingLike</span></code></dt>
<dd>
<div class="desc"><p>Type alias for things that could be used to specify couplings,
namely any collection of <code>int</code> (subject to additional restrictions).</p>
<p>In an ideal world, this should be "int collections of len 2",
but static typing does not yet allow for such a constraint.</p></div>
</dd>
<dt id="pauliopt.topologies.Layouts"><code class="name">var <span class="ident">Layouts</span> : Final[Tuple[str, ...]]</code></dt>
<dd>
<div class="desc"><p>Possible layout values for <code><a title="pauliopt.topologies.Topology.draw" href="#pauliopt.topologies.Topology.draw">Topology.draw()</a></code></p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pauliopt.topologies.Coupling"><code class="flex name class">
<span>class <span class="ident">Coupling</span></span>
<span>(</span><span>fst: int, snd: int)</span>
</code></dt>
<dd>
<div class="desc"><p>Type for couplings in a qubit topology, i.e. unordered
pairs of adjacent qubits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Coupling(FrozenSet[int]):
    &#34;&#34;&#34;
        Type for couplings in a qubit topology, i.e. unordered
        pairs of adjacent qubits.
    &#34;&#34;&#34;
    def __new__(cls, fst: int, snd: int):
        if not isinstance(fst, int):
            raise TypeError(f&#34;Expected integer, found {fst}&#34;)
        if not isinstance(snd, int):
            raise TypeError(f&#34;Expected integer, found {snd}&#34;)
        if len({fst, snd}) != 2:
            raise ValueError(&#34;Expected a pair of distinct qubits.&#34;)
        # see https://github.com/python/mypy/issues/6061
        return super(Coupling, cls).__new__(cls, {fst, snd}) # type: ignore

    @property
    def as_pair(self) -&gt; Tuple[int, int]:
        &#34;&#34;&#34;
            Returns the coupling as a (increasingly) ordered pair.
        &#34;&#34;&#34;
        return (min(*self), max(*self)) # pylint: disable = not-an-iterable

    def __str__(self) -&gt; str:
        fst, snd = sorted(self)
        return f&#34;{{{fst}, {snd}}}&#34;

    def __repr__(self) -&gt; str:
        fst, snd = sorted(self)
        return f&#34;Coupling({fst}, {snd})&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.frozenset</li>
<li>typing.Generic</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.topologies.Coupling.as_pair"><code class="name">var <span class="ident">as_pair</span> : Tuple[int, int]</code></dt>
<dd>
<div class="desc"><p>Returns the coupling as a (increasingly) ordered pair.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_pair(self) -&gt; Tuple[int, int]:
    &#34;&#34;&#34;
        Returns the coupling as a (increasingly) ordered pair.
    &#34;&#34;&#34;
    return (min(*self), max(*self)) # pylint: disable = not-an-iterable</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pauliopt.topologies.Matching"><code class="flex name class">
<span>class <span class="ident">Matching</span></span>
<span>(</span><span>topology: <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Mutable container class for a matching on a qubit topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Matching:
    &#34;&#34;&#34;
        Mutable container class for a matching on a qubit topology.
    &#34;&#34;&#34;

    _topology: Topology
    _matched_couplings: Set[Coupling]
    _matched_qubits: Set[int]
    _incident_coupling: List[Optional[Coupling]]

    def __init__(self, topology: Topology):
        if not isinstance(topology, Topology):
            raise TypeError(f&#34;Expected Topology, found {topology}.&#34;)
        self._topology = topology
        self._matched_couplings = set()
        self._matched_qubits = set()
        self._incident_coupling = [None for _ in topology.qubits]

    @property
    def topology(self) -&gt; Topology:
        &#34;&#34;&#34;
            Readonly property exposing the qubit topology
            underlying this matching.
        &#34;&#34;&#34;
        return self._topology

    @property
    def matched_couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning the collection of couplings
            currently in this matching.

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._matched_couplings)

    @property
    def matched_qubits(self) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property returning the collection of qubits
            currently matched in this matching.

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._matched_qubits)

    @property
    def flippable_couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning the collection of couplings
            that can be currently flipped in this matching, namely:

            - all couplings currently in the matching (will be removed by flip);
            - all couplings with both qubits currently not matched by the matching
              (will be added by flip).

            This collection is freshly generated at every call.
        &#34;&#34;&#34;
        return frozenset(self._iter_flippable_couplings())

    def incident(self, qubit: int) -&gt; Optional[Coupling]:
        &#34;&#34;&#34;
            Returns the coupling incident to the given qubit in this matching,
            or `None` if the qubit is not matched.
        &#34;&#34;&#34;
        return self._incident_coupling[qubit]

    def is_flippable(self, coupling: CouplingLike) -&gt; bool:
        &#34;&#34;&#34;
            Checks whether the coupling can be flipped:

            - always true if the coupling is already present in the matching;
            - otherwise true only if neither qubit in the coupling is currently matched.
        &#34;&#34;&#34;
        coupling = _validate_coupling(self.topology.num_qubits, coupling)
        if coupling not in self.topology.couplings:
            raise ValueError(f&#34;Invalid coupling {coupling} for the given topology.&#34;)
        return self._is_flippable(coupling)

    def flip(self, coupling: CouplingLike) -&gt; &#34;Matching&#34;:
        &#34;&#34;&#34;
            Flips the given coupling in the matching (removes it if it is already present,
            adds it if it is not yed present and can be added).
            Raises `ValueError` if the coupling is not flippable.

            The matching is modified in-place and then returned, as per the
            [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
        &#34;&#34;&#34;
        coupling = _validate_coupling(self.topology.num_qubits, coupling)
        return self._flip(coupling)

    def _is_flippable(self, coupling: Coupling) -&gt; bool:
        if coupling in self._matched_couplings:
            return True
        fst, snd = coupling
        if fst in self._matched_qubits:
            return False
        if snd in self._matched_qubits:
            return False
        return True

    def _flip(self, coupling: Coupling) -&gt; &#34;Matching&#34;:
        if not self._is_flippable(coupling):
            raise ValueError(f&#34;Cannot add coupling {coupling} to matching:&#34;
                             f&#34;one of the qubits is already matched. &#34;)
        fst, snd = coupling
        if coupling in self._matched_couplings:
            self._matched_couplings.remove(coupling)
            self._matched_qubits.remove(fst)
            self._matched_qubits.remove(snd)
            self._incident_coupling[fst] = None
            self._incident_coupling[snd] = None
        else:
            self._matched_couplings.add(coupling)
            self._matched_qubits.add(fst)
            self._matched_qubits.add(snd)
            self._incident_coupling[fst] = coupling
            self._incident_coupling[snd] = coupling
        return self

    def _iter_flippable_couplings(self) -&gt; Iterator[Coupling]:
        for coupling in self._topology.couplings:
            fst, snd = coupling
            if coupling in self._matched_couplings:
                yield coupling
            elif fst not in self._matched_qubits and snd not in self._matched_qubits:
                yield coupling
            else:
                # coupling is not flippable
                pass</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.topologies.Matching.flippable_couplings"><code class="name">var <span class="ident">flippable_couplings</span> : FrozenSet[<a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a>]</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the collection of couplings
that can be currently flipped in this matching, namely:</p>
<ul>
<li>all couplings currently in the matching (will be removed by flip);</li>
<li>all couplings with both qubits currently not matched by the matching
(will be added by flip).</li>
</ul>
<p>This collection is freshly generated at every call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def flippable_couplings(self) -&gt; FrozenSet[Coupling]:
    &#34;&#34;&#34;
        Readonly property returning the collection of couplings
        that can be currently flipped in this matching, namely:

        - all couplings currently in the matching (will be removed by flip);
        - all couplings with both qubits currently not matched by the matching
          (will be added by flip).

        This collection is freshly generated at every call.
    &#34;&#34;&#34;
    return frozenset(self._iter_flippable_couplings())</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Matching.matched_couplings"><code class="name">var <span class="ident">matched_couplings</span> : FrozenSet[<a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a>]</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the collection of couplings
currently in this matching.</p>
<p>This collection is freshly generated at every call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def matched_couplings(self) -&gt; FrozenSet[Coupling]:
    &#34;&#34;&#34;
        Readonly property returning the collection of couplings
        currently in this matching.

        This collection is freshly generated at every call.
    &#34;&#34;&#34;
    return frozenset(self._matched_couplings)</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Matching.matched_qubits"><code class="name">var <span class="ident">matched_qubits</span> : FrozenSet[int]</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the collection of qubits
currently matched in this matching.</p>
<p>This collection is freshly generated at every call.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def matched_qubits(self) -&gt; FrozenSet[int]:
    &#34;&#34;&#34;
        Readonly property returning the collection of qubits
        currently matched in this matching.

        This collection is freshly generated at every call.
    &#34;&#34;&#34;
    return frozenset(self._matched_qubits)</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Matching.topology"><code class="name">var <span class="ident">topology</span> : <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the qubit topology
underlying this matching.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def topology(self) -&gt; Topology:
    &#34;&#34;&#34;
        Readonly property exposing the qubit topology
        underlying this matching.
    &#34;&#34;&#34;
    return self._topology</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.topologies.Matching.flip"><code class="name flex">
<span>def <span class="ident">flip</span></span>(<span>self, coupling: Collection[int]) ‑> <a title="pauliopt.topologies.Matching" href="#pauliopt.topologies.Matching">Matching</a></span>
</code></dt>
<dd>
<div class="desc"><p>Flips the given coupling in the matching (removes it if it is already present,
adds it if it is not yed present and can be added).
Raises <code>ValueError</code> if the coupling is not flippable.</p>
<p>The matching is modified in-place and then returned, as per the
<a href="https://en.wikipedia.org/wiki/Fluent_interface">fluent API pattern</a>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def flip(self, coupling: CouplingLike) -&gt; &#34;Matching&#34;:
    &#34;&#34;&#34;
        Flips the given coupling in the matching (removes it if it is already present,
        adds it if it is not yed present and can be added).
        Raises `ValueError` if the coupling is not flippable.

        The matching is modified in-place and then returned, as per the
        [fluent API pattern](https://en.wikipedia.org/wiki/Fluent_interface).
    &#34;&#34;&#34;
    coupling = _validate_coupling(self.topology.num_qubits, coupling)
    return self._flip(coupling)</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Matching.incident"><code class="name flex">
<span>def <span class="ident">incident</span></span>(<span>self, qubit: int) ‑> Union[<a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a>, NoneType]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the coupling incident to the given qubit in this matching,
or <code>None</code> if the qubit is not matched.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incident(self, qubit: int) -&gt; Optional[Coupling]:
    &#34;&#34;&#34;
        Returns the coupling incident to the given qubit in this matching,
        or `None` if the qubit is not matched.
    &#34;&#34;&#34;
    return self._incident_coupling[qubit]</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Matching.is_flippable"><code class="name flex">
<span>def <span class="ident">is_flippable</span></span>(<span>self, coupling: Collection[int]) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks whether the coupling can be flipped:</p>
<ul>
<li>always true if the coupling is already present in the matching;</li>
<li>otherwise true only if neither qubit in the coupling is currently matched.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_flippable(self, coupling: CouplingLike) -&gt; bool:
    &#34;&#34;&#34;
        Checks whether the coupling can be flipped:

        - always true if the coupling is already present in the matching;
        - otherwise true only if neither qubit in the coupling is currently matched.
    &#34;&#34;&#34;
    coupling = _validate_coupling(self.topology.num_qubits, coupling)
    if coupling not in self.topology.couplings:
        raise ValueError(f&#34;Invalid coupling {coupling} for the given topology.&#34;)
    return self._is_flippable(coupling)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pauliopt.topologies.Topology"><code class="flex name class">
<span>class <span class="ident">Topology</span></span>
<span>(</span><span>num_qubits: int, couplings: Collection[Collection[int]])</span>
</code></dt>
<dd>
<div class="desc"><p>Container class for a qubit topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Topology:
    &#34;&#34;&#34;
        Container class for a qubit topology.
    &#34;&#34;&#34;
    _num_qubits: int
    _couplings: FrozenSet[Coupling]
    _adjacent: Tuple[FrozenSet[int], ...]
    _dist: np.ndarray
    _named: Optional[str] = None

    def __init__(self, num_qubits: int, couplings: Collection[CouplingLike]):
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be a positive integer.&#34;)
        if not isinstance(couplings, Collection):
            raise TypeError(&#34;Couplings must be a collection of pairs of qubits.&#34;)
        self._num_qubits = num_qubits
        self._couplings = frozenset(_validate_coupling(num_qubits, c) for c in couplings)
        _adjacent: Tuple[Set[int], ...] = tuple(set() for _ in range(num_qubits))
        for fst, snd in self.couplings:
            _adjacent[fst].add(snd)
            _adjacent[snd].add(fst)
        self._adjacent = tuple(frozenset(n) for n in _adjacent)
        self._dist = _floyd_warshall(self)

    @property
    def num_qubits(self) -&gt; int:
        &#34;&#34;&#34;
            Readonly property returning the number of qubits in this topology.
        &#34;&#34;&#34;
        return self._num_qubits

    @property
    def qubits(self) -&gt; range:
        &#34;&#34;&#34;
            Readonly property returning the range of qubits in this topology.
        &#34;&#34;&#34;
        return range(self._num_qubits)

    @property
    def couplings(self) -&gt; FrozenSet[Coupling]:
        &#34;&#34;&#34;
            Readonly property exposing the couplings between qubits in this topology.
        &#34;&#34;&#34;
        return self._couplings

    @property
    def as_dict(self) -&gt; Union[str, TopologyDict]:
        &#34;&#34;&#34;
            Readonly property returning this topology as
            a dictionary, for serialization purposes.
        &#34;&#34;&#34;
        if self._named is not None:
            return self._named
        return {
            &#34;num_qubits&#34;: self.num_qubits,
            &#34;couplings&#34;: sorted(list(c.as_pair) for c in self.couplings)
        }

    @property
    def is_planar(self) -&gt; bool:
        &#34;&#34;&#34;
            Whether this qubit topology is a planar graph.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as e: # pylint: disable = unused-variable
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        G = self.to_nx
        is_planar, _ = nx.check_planarity(G)
        return is_planar

    @property
    def available_nx_layouts(self) -&gt; Tuple[str, ...]:
        &#34;&#34;&#34;
            Readonly property returning the available layouts for this qubit topology.
        &#34;&#34;&#34;
        if self.is_planar:
            return Layouts+(&#34;planar&#34;,)
        return Layouts

    @property
    def to_nx(self):
        &#34;&#34;&#34;
            Readonly property returning a NetworkX graph version of this topology.
            Requires the &#39;networkx&#39; library to work.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        g = nx.Graph()
        g.add_nodes_from(sorted(self.qubits))
        g.add_edges_from(sorted(self.couplings, key=lambda c: c.as_pair))
        return g

    def draw(self, layout: str = &#34;kamada_kawai&#34;, *,
             figsize: Optional[Tuple[int, int]] = None,
             **kwargs):
        &#34;&#34;&#34;
            Draws this qubit topology using NetworkX and Matplotlib.

            The `layout` keyword argument can be used to select a NetworkX layout
            from the available ones (exposed by `Topology.available_nx_layouts`).
            The `figsize` keyword argument is passed to `matplotlib.pyplot.figure`:
            if specified, it determines the width and height of the figure being drawn.
            Keyword arguments `kwargs` are those of `networkx.draw_networkx`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            import networkx as nx # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
        try:
            # pylint: disable = import-outside-toplevel
            import matplotlib.pyplot as plt # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;matplotlib&#39; library.&#34;)
        G = self.to_nx
        kwargs = {**kwargs}
        layouts = self.available_nx_layouts
        if &#34;pos&#34; not in kwargs:
            if layout not in layouts:
                raise ValueError(f&#34;Invalid layout found: {layout}. &#34;
                                 f&#34;Valid layouts: {&#39;, &#39;.join(repr(l) for l in layouts)}&#34;)
            kwargs[&#34;pos&#34;] = getattr(nx, layout+&#34;_layout&#34;)(G)
        if &#34;node_color&#34; not in kwargs:
            kwargs[&#34;node_color&#34;] = &#34;#dddddd&#34;
        plt.figure(figsize=figsize)
        nx.draw_networkx(G, **kwargs)
        plt.show()

    def adjacent(self, qubit: int) -&gt; FrozenSet[int]:
        &#34;&#34;&#34;
            Readonly property exposing the (frozen) set of qubits adjacent
            to (i.e. couple with) the given qubit.
        &#34;&#34;&#34;
        if not isinstance(qubit, int):
            raise TypeError(&#34;Qubit should be an integer.&#34;)
        if qubit not in self:
            raise ValueError(f&#34;Invalid qubit {qubit}.&#34;)
        return self._adjacent[qubit]

    def incident(self, qubit: int) -&gt; Iterator[Coupling]:
        &#34;&#34;&#34;
            Readonly property returning an iterator running over all couplings
            incident onto the given qubit.

            This is returned as an iterator, rather than a collection,
            because the couplings are generated on the fly (i.e. this is not
            merely exposing some internal collection).
        &#34;&#34;&#34;
        adjacent = self.adjacent(qubit)
        return (Coupling(qubit, q) for q in adjacent)

    def dist(self, fro: int, to: int) -&gt; int:
        &#34;&#34;&#34;
            Returns the distance between two given qubits in the topology.
        &#34;&#34;&#34;
        if not isinstance(fro, int) or fro not in self:
            raise TypeError(f&#34;Expected a valid qubit, found {fro}.&#34;)
        if not isinstance(to, int) or to not in self:
            raise TypeError(f&#34;Expected a valid qubit, found {to}.&#34;)
        return self._dist[fro, to]

    def __contains__(self, x: Union[int, Coupling, Tuple[int, int]]) -&gt; bool:
        if isinstance(x, int):
            return 0 &lt;= x &lt; self._num_qubits
        if isinstance(x, Coupling):
            return x in self._couplings
        if isinstance(x, tuple) and len(x) == 2:
            fst, snd = x
            if isinstance(fst, int) and isinstance(snd, int):
                return Coupling(fst, snd) in self
        raise TypeError(f&#34;Expected qubit or coupling, found {x}&#34;)

    def __repr__(self) -&gt; str:
        if self.couplings:
            return (f&#34;Topology({set(self.qubits)}, &#34;
                    f&#34;[{&#39;, &#39;.join(str(c) for c in self.couplings)}])&#34;)
        return f&#34;Topology({set(self.qubits)})&#34;

    def __hash__(self) -&gt; int:
        return hash((self.qubits, self.couplings))

    def __eq__(self, other) -&gt; bool:
        if self is other:
            return True
        if not isinstance(other, Topology):
            return NotImplemented
        if self.qubits != other.qubits:
            return False
        if self.couplings != other.couplings:
            return False
        return True

    @staticmethod
    def from_dict(topology: Union[TopologyDict, str]) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a `Topology` instance from a dictionary in the
            format obtained from `Topology.as_dict`,
            for de-serialization purposes.
        &#34;&#34;&#34;
        if isinstance(topology, str):
            line_pattern = re.compile(r&#34;line\(([0-9]+)\)&#34;)
            if match := line_pattern.match(topology):
                return Topology.line(int(match[1]))
            cycle_pattern = re.compile(r&#34;cycle\(([0-9]+)\)&#34;)
            if match := cycle_pattern.match(topology):
                return Topology.cycle(int(match[1]))
            complete_pattern = re.compile(r&#34;complete\(([0-9]+)\)&#34;)
            if match := complete_pattern.match(topology):
                return Topology.complete(int(match[1]))
            grid_pattern = re.compile(r&#34;grid\(([0-9]+),([0-9]+)\)&#34;)
            if match := grid_pattern.match(topology):
                return Topology.grid(int(match[1]), int(match[2]))
            periodic_grid_pattern = re.compile(r&#34;periodic_grid\(([0-9]+),([0-9]+)\)&#34;)
            if match := periodic_grid_pattern.match(topology):
                return Topology.periodic_grid(int(match[1]), int(match[2]))
            raise ValueError(f&#34;Unexpected special topology {topology}&#34;)
        if &#34;num_qubits&#34; not in topology:
            raise TypeError(&#34;Expected key &#39;qubits&#39;.&#34;)
        if &#34;couplings&#34; not in topology:
            raise TypeError(&#34;Expected key &#39;couplings&#39;.&#34;)
        return Topology(topology[&#34;num_qubits&#34;], topology[&#34;couplings&#34;])

    @staticmethod
    def line(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a line topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, i+1] for i in range(num_qubits-1)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;line({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def cycle(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a cycle topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, (i+1)%num_qubits] for i in range(num_qubits)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;cycle({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def complete(num_qubits: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a complete topology on the given number of qubits.
        &#34;&#34;&#34;
        if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
            raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
        couplings = [[i, j] for i in range(num_qubits) for j in range(i+1, num_qubits)]
        top = Topology(num_qubits, couplings)
        top._named = f&#34;complete({num_qubits})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a grid topology with the given number of rows and cols.
            Qubits are indexed by rows.
        &#34;&#34;&#34;
        if not isinstance(num_rows, int) or num_rows &lt;= 0:
            raise TypeError(&#34;Number of rows must be positive integer.&#34;)
        if not isinstance(num_cols, int) or num_cols &lt;= 0:
            raise TypeError(&#34;Number of cols must be positive integer.&#34;)
        num_qubits = num_rows * num_cols
        def qubit(r, c):
            return num_cols*r + c
        couplings: List[List[int]] = []
        for r in range(num_rows):
            for c in range(num_cols):
                if r &lt; num_rows-1:
                    couplings.append([qubit(r, c), qubit(r+1, c)])
                if c &lt; num_cols-1:
                    couplings.append([qubit(r, c), qubit(r, c+1)])
        top = Topology(num_qubits, couplings)
        top._named = f&#34;grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def periodic_grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Creates a periodic grid topology with the given number of rows and cols.
            Qubits are indexed by rows.
        &#34;&#34;&#34;
        if not isinstance(num_rows, int) or num_rows &lt;= 0:
            raise TypeError(&#34;Number of rows must be positive integer.&#34;)
        if not isinstance(num_cols, int) or num_cols &lt;= 0:
            raise TypeError(&#34;Number of cols must be positive integer.&#34;)
        num_qubits = num_rows * num_cols
        def qubit(r, c):
            return num_cols*r + c
        couplings: List[List[int]] = []
        for r in range(num_rows):
            for c in range(num_cols):
                couplings.append([qubit(r, c), qubit((r+1)%num_rows, c)])
                couplings.append([qubit(r, c), qubit(r, (c+1)%num_cols)])
        top = Topology(num_qubits, couplings)
        top._named = f&#34;periodic_grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
        return top

    @staticmethod
    def from_qiskit_config(config) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Static method to construct the topology from a
            Qiskit backend configuration.

            This method relies on the `qiskit` library being available.
            Specifically, the `config` argument must be of type
            `qiskit.providers.models.QasmBackendConfiguration`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel
            from qiskit.providers.models import QasmBackendConfiguration # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        if not isinstance(config, QasmBackendConfiguration):
            raise TypeError(&#34;Argument backend must be of type &#34;
                            &#34;`qiskit.providers.models.QasmBackendConfiguration`, &#34;
                            f&#34;found {type(config)}.&#34;)
        config_dict = config.to_dict()
        num_qubits: int = config_dict[&#34;n_qubits&#34;]
        coupling_map: List[List[int]] = config_dict[&#34;coupling_map&#34;]
        return Topology(num_qubits, coupling_map)

    @staticmethod
    def from_qiskit_backend(backend) -&gt; &#34;Topology&#34;:
        &#34;&#34;&#34;
            Static method to construct the topology from a Qiskit backend.

            This method relies on the `qiskit` library being available.
            Specifically, the `backend` argument must be of type
            `qiskit.providers.BaseBackend`.
        &#34;&#34;&#34;
        try:
            # pylint: disable = import-outside-toplevel, unused-import
            from qiskit.providers import BaseBackend # type: ignore
        except ModuleNotFoundError as _:
            raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
        if not isinstance(backend, BaseBackend):
            raise TypeError(&#34;Argument backend must be of type &#34;
                            &#34;`qiskit.providers.BaseBackend`.&#34;)
        return Topology.from_qiskit_config(backend.configuration())</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pauliopt.topologies.Topology.complete"><code class="name flex">
<span>def <span class="ident">complete</span></span>(<span>num_qubits: int) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a complete topology on the given number of qubits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def complete(num_qubits: int) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a complete topology on the given number of qubits.
    &#34;&#34;&#34;
    if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
        raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
    couplings = [[i, j] for i in range(num_qubits) for j in range(i+1, num_qubits)]
    top = Topology(num_qubits, couplings)
    top._named = f&#34;complete({num_qubits})&#34; # pylint: disable = protected-access
    return top</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.cycle"><code class="name flex">
<span>def <span class="ident">cycle</span></span>(<span>num_qubits: int) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a cycle topology on the given number of qubits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def cycle(num_qubits: int) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a cycle topology on the given number of qubits.
    &#34;&#34;&#34;
    if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
        raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
    couplings = [[i, (i+1)%num_qubits] for i in range(num_qubits)]
    top = Topology(num_qubits, couplings)
    top._named = f&#34;cycle({num_qubits})&#34; # pylint: disable = protected-access
    return top</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.from_dict"><code class="name flex">
<span>def <span class="ident">from_dict</span></span>(<span>topology: Union[<a title="pauliopt.topologies.TopologyDict" href="#pauliopt.topologies.TopologyDict">TopologyDict</a>, str]) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a <code><a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></code> instance from a dictionary in the
format obtained from <code><a title="pauliopt.topologies.Topology.as_dict" href="#pauliopt.topologies.Topology.as_dict">Topology.as_dict</a></code>,
for de-serialization purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_dict(topology: Union[TopologyDict, str]) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a `Topology` instance from a dictionary in the
        format obtained from `Topology.as_dict`,
        for de-serialization purposes.
    &#34;&#34;&#34;
    if isinstance(topology, str):
        line_pattern = re.compile(r&#34;line\(([0-9]+)\)&#34;)
        if match := line_pattern.match(topology):
            return Topology.line(int(match[1]))
        cycle_pattern = re.compile(r&#34;cycle\(([0-9]+)\)&#34;)
        if match := cycle_pattern.match(topology):
            return Topology.cycle(int(match[1]))
        complete_pattern = re.compile(r&#34;complete\(([0-9]+)\)&#34;)
        if match := complete_pattern.match(topology):
            return Topology.complete(int(match[1]))
        grid_pattern = re.compile(r&#34;grid\(([0-9]+),([0-9]+)\)&#34;)
        if match := grid_pattern.match(topology):
            return Topology.grid(int(match[1]), int(match[2]))
        periodic_grid_pattern = re.compile(r&#34;periodic_grid\(([0-9]+),([0-9]+)\)&#34;)
        if match := periodic_grid_pattern.match(topology):
            return Topology.periodic_grid(int(match[1]), int(match[2]))
        raise ValueError(f&#34;Unexpected special topology {topology}&#34;)
    if &#34;num_qubits&#34; not in topology:
        raise TypeError(&#34;Expected key &#39;qubits&#39;.&#34;)
    if &#34;couplings&#34; not in topology:
        raise TypeError(&#34;Expected key &#39;couplings&#39;.&#34;)
    return Topology(topology[&#34;num_qubits&#34;], topology[&#34;couplings&#34;])</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.from_qiskit_backend"><code class="name flex">
<span>def <span class="ident">from_qiskit_backend</span></span>(<span>backend) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Static method to construct the topology from a Qiskit backend.</p>
<p>This method relies on the <code>qiskit</code> library being available.
Specifically, the <code>backend</code> argument must be of type
<code>qiskit.providers.BaseBackend</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_qiskit_backend(backend) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Static method to construct the topology from a Qiskit backend.

        This method relies on the `qiskit` library being available.
        Specifically, the `backend` argument must be of type
        `qiskit.providers.BaseBackend`.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel, unused-import
        from qiskit.providers import BaseBackend # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
    if not isinstance(backend, BaseBackend):
        raise TypeError(&#34;Argument backend must be of type &#34;
                        &#34;`qiskit.providers.BaseBackend`.&#34;)
    return Topology.from_qiskit_config(backend.configuration())</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.from_qiskit_config"><code class="name flex">
<span>def <span class="ident">from_qiskit_config</span></span>(<span>config) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Static method to construct the topology from a
Qiskit backend configuration.</p>
<p>This method relies on the <code>qiskit</code> library being available.
Specifically, the <code>config</code> argument must be of type
<code>qiskit.providers.models.QasmBackendConfiguration</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_qiskit_config(config) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Static method to construct the topology from a
        Qiskit backend configuration.

        This method relies on the `qiskit` library being available.
        Specifically, the `config` argument must be of type
        `qiskit.providers.models.QasmBackendConfiguration`.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        from qiskit.providers.models import QasmBackendConfiguration # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;qiskit&#39; library.&#34;)
    if not isinstance(config, QasmBackendConfiguration):
        raise TypeError(&#34;Argument backend must be of type &#34;
                        &#34;`qiskit.providers.models.QasmBackendConfiguration`, &#34;
                        f&#34;found {type(config)}.&#34;)
    config_dict = config.to_dict()
    num_qubits: int = config_dict[&#34;n_qubits&#34;]
    coupling_map: List[List[int]] = config_dict[&#34;coupling_map&#34;]
    return Topology(num_qubits, coupling_map)</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>num_rows: int, num_cols: int) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a grid topology with the given number of rows and cols.
Qubits are indexed by rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a grid topology with the given number of rows and cols.
        Qubits are indexed by rows.
    &#34;&#34;&#34;
    if not isinstance(num_rows, int) or num_rows &lt;= 0:
        raise TypeError(&#34;Number of rows must be positive integer.&#34;)
    if not isinstance(num_cols, int) or num_cols &lt;= 0:
        raise TypeError(&#34;Number of cols must be positive integer.&#34;)
    num_qubits = num_rows * num_cols
    def qubit(r, c):
        return num_cols*r + c
    couplings: List[List[int]] = []
    for r in range(num_rows):
        for c in range(num_cols):
            if r &lt; num_rows-1:
                couplings.append([qubit(r, c), qubit(r+1, c)])
            if c &lt; num_cols-1:
                couplings.append([qubit(r, c), qubit(r, c+1)])
    top = Topology(num_qubits, couplings)
    top._named = f&#34;grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
    return top</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.line"><code class="name flex">
<span>def <span class="ident">line</span></span>(<span>num_qubits: int) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a line topology on the given number of qubits.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def line(num_qubits: int) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a line topology on the given number of qubits.
    &#34;&#34;&#34;
    if not isinstance(num_qubits, int) or num_qubits &lt;= 0:
        raise TypeError(&#34;Number of qubits must be positive integer.&#34;)
    couplings = [[i, i+1] for i in range(num_qubits-1)]
    top = Topology(num_qubits, couplings)
    top._named = f&#34;line({num_qubits})&#34; # pylint: disable = protected-access
    return top</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.periodic_grid"><code class="name flex">
<span>def <span class="ident">periodic_grid</span></span>(<span>num_rows: int, num_cols: int) ‑> <a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates a periodic grid topology with the given number of rows and cols.
Qubits are indexed by rows.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def periodic_grid(num_rows: int, num_cols: int) -&gt; &#34;Topology&#34;:
    &#34;&#34;&#34;
        Creates a periodic grid topology with the given number of rows and cols.
        Qubits are indexed by rows.
    &#34;&#34;&#34;
    if not isinstance(num_rows, int) or num_rows &lt;= 0:
        raise TypeError(&#34;Number of rows must be positive integer.&#34;)
    if not isinstance(num_cols, int) or num_cols &lt;= 0:
        raise TypeError(&#34;Number of cols must be positive integer.&#34;)
    num_qubits = num_rows * num_cols
    def qubit(r, c):
        return num_cols*r + c
    couplings: List[List[int]] = []
    for r in range(num_rows):
        for c in range(num_cols):
            couplings.append([qubit(r, c), qubit((r+1)%num_rows, c)])
            couplings.append([qubit(r, c), qubit(r, (c+1)%num_cols)])
    top = Topology(num_qubits, couplings)
    top._named = f&#34;periodic_grid({num_rows},{num_cols})&#34; # pylint: disable = protected-access
    return top</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pauliopt.topologies.Topology.as_dict"><code class="name">var <span class="ident">as_dict</span> : Union[str, <a title="pauliopt.topologies.TopologyDict" href="#pauliopt.topologies.TopologyDict">TopologyDict</a>]</code></dt>
<dd>
<div class="desc"><p>Readonly property returning this topology as
a dictionary, for serialization purposes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def as_dict(self) -&gt; Union[str, TopologyDict]:
    &#34;&#34;&#34;
        Readonly property returning this topology as
        a dictionary, for serialization purposes.
    &#34;&#34;&#34;
    if self._named is not None:
        return self._named
    return {
        &#34;num_qubits&#34;: self.num_qubits,
        &#34;couplings&#34;: sorted(list(c.as_pair) for c in self.couplings)
    }</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.available_nx_layouts"><code class="name">var <span class="ident">available_nx_layouts</span> : Tuple[str, ...]</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the available layouts for this qubit topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def available_nx_layouts(self) -&gt; Tuple[str, ...]:
    &#34;&#34;&#34;
        Readonly property returning the available layouts for this qubit topology.
    &#34;&#34;&#34;
    if self.is_planar:
        return Layouts+(&#34;planar&#34;,)
    return Layouts</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.couplings"><code class="name">var <span class="ident">couplings</span> : FrozenSet[<a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a>]</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the couplings between qubits in this topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def couplings(self) -&gt; FrozenSet[Coupling]:
    &#34;&#34;&#34;
        Readonly property exposing the couplings between qubits in this topology.
    &#34;&#34;&#34;
    return self._couplings</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.is_planar"><code class="name">var <span class="ident">is_planar</span> : bool</code></dt>
<dd>
<div class="desc"><p>Whether this qubit topology is a planar graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_planar(self) -&gt; bool:
    &#34;&#34;&#34;
        Whether this qubit topology is a planar graph.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        import networkx as nx # type: ignore
    except ModuleNotFoundError as e: # pylint: disable = unused-variable
        raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
    G = self.to_nx
    is_planar, _ = nx.check_planarity(G)
    return is_planar</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.num_qubits"><code class="name">var <span class="ident">num_qubits</span> : int</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the number of qubits in this topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def num_qubits(self) -&gt; int:
    &#34;&#34;&#34;
        Readonly property returning the number of qubits in this topology.
    &#34;&#34;&#34;
    return self._num_qubits</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.qubits"><code class="name">var <span class="ident">qubits</span> : range</code></dt>
<dd>
<div class="desc"><p>Readonly property returning the range of qubits in this topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def qubits(self) -&gt; range:
    &#34;&#34;&#34;
        Readonly property returning the range of qubits in this topology.
    &#34;&#34;&#34;
    return range(self._num_qubits)</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.to_nx"><code class="name">var <span class="ident">to_nx</span></code></dt>
<dd>
<div class="desc"><p>Readonly property returning a NetworkX graph version of this topology.
Requires the 'networkx' library to work.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def to_nx(self):
    &#34;&#34;&#34;
        Readonly property returning a NetworkX graph version of this topology.
        Requires the &#39;networkx&#39; library to work.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        import networkx as nx # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
    g = nx.Graph()
    g.add_nodes_from(sorted(self.qubits))
    g.add_edges_from(sorted(self.couplings, key=lambda c: c.as_pair))
    return g</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pauliopt.topologies.Topology.adjacent"><code class="name flex">
<span>def <span class="ident">adjacent</span></span>(<span>self, qubit: int) ‑> FrozenSet[int]</span>
</code></dt>
<dd>
<div class="desc"><p>Readonly property exposing the (frozen) set of qubits adjacent
to (i.e. couple with) the given qubit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjacent(self, qubit: int) -&gt; FrozenSet[int]:
    &#34;&#34;&#34;
        Readonly property exposing the (frozen) set of qubits adjacent
        to (i.e. couple with) the given qubit.
    &#34;&#34;&#34;
    if not isinstance(qubit, int):
        raise TypeError(&#34;Qubit should be an integer.&#34;)
    if qubit not in self:
        raise ValueError(f&#34;Invalid qubit {qubit}.&#34;)
    return self._adjacent[qubit]</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, fro: int, to: int) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the distance between two given qubits in the topology.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dist(self, fro: int, to: int) -&gt; int:
    &#34;&#34;&#34;
        Returns the distance between two given qubits in the topology.
    &#34;&#34;&#34;
    if not isinstance(fro, int) or fro not in self:
        raise TypeError(f&#34;Expected a valid qubit, found {fro}.&#34;)
    if not isinstance(to, int) or to not in self:
        raise TypeError(f&#34;Expected a valid qubit, found {to}.&#34;)
    return self._dist[fro, to]</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.draw"><code class="name flex">
<span>def <span class="ident">draw</span></span>(<span>self, layout: str = 'kamada_kawai', *, figsize: Union[Tuple[int, int], NoneType] = None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Draws this qubit topology using NetworkX and Matplotlib.</p>
<p>The <code>layout</code> keyword argument can be used to select a NetworkX layout
from the available ones (exposed by <code><a title="pauliopt.topologies.Topology.available_nx_layouts" href="#pauliopt.topologies.Topology.available_nx_layouts">Topology.available_nx_layouts</a></code>).
The <code>figsize</code> keyword argument is passed to <code>matplotlib.pyplot.figure</code>:
if specified, it determines the width and height of the figure being drawn.
Keyword arguments <code>kwargs</code> are those of <code>networkx.draw_networkx</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw(self, layout: str = &#34;kamada_kawai&#34;, *,
         figsize: Optional[Tuple[int, int]] = None,
         **kwargs):
    &#34;&#34;&#34;
        Draws this qubit topology using NetworkX and Matplotlib.

        The `layout` keyword argument can be used to select a NetworkX layout
        from the available ones (exposed by `Topology.available_nx_layouts`).
        The `figsize` keyword argument is passed to `matplotlib.pyplot.figure`:
        if specified, it determines the width and height of the figure being drawn.
        Keyword arguments `kwargs` are those of `networkx.draw_networkx`.
    &#34;&#34;&#34;
    try:
        # pylint: disable = import-outside-toplevel
        import networkx as nx # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;networkx&#39; library.&#34;)
    try:
        # pylint: disable = import-outside-toplevel
        import matplotlib.pyplot as plt # type: ignore
    except ModuleNotFoundError as _:
        raise ModuleNotFoundError(&#34;You must install the &#39;matplotlib&#39; library.&#34;)
    G = self.to_nx
    kwargs = {**kwargs}
    layouts = self.available_nx_layouts
    if &#34;pos&#34; not in kwargs:
        if layout not in layouts:
            raise ValueError(f&#34;Invalid layout found: {layout}. &#34;
                             f&#34;Valid layouts: {&#39;, &#39;.join(repr(l) for l in layouts)}&#34;)
        kwargs[&#34;pos&#34;] = getattr(nx, layout+&#34;_layout&#34;)(G)
    if &#34;node_color&#34; not in kwargs:
        kwargs[&#34;node_color&#34;] = &#34;#dddddd&#34;
    plt.figure(figsize=figsize)
    nx.draw_networkx(G, **kwargs)
    plt.show()</code></pre>
</details>
</dd>
<dt id="pauliopt.topologies.Topology.incident"><code class="name flex">
<span>def <span class="ident">incident</span></span>(<span>self, qubit: int) ‑> Iterator[<a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Readonly property returning an iterator running over all couplings
incident onto the given qubit.</p>
<p>This is returned as an iterator, rather than a collection,
because the couplings are generated on the fly (i.e. this is not
merely exposing some internal collection).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def incident(self, qubit: int) -&gt; Iterator[Coupling]:
    &#34;&#34;&#34;
        Readonly property returning an iterator running over all couplings
        incident onto the given qubit.

        This is returned as an iterator, rather than a collection,
        because the couplings are generated on the fly (i.e. this is not
        merely exposing some internal collection).
    &#34;&#34;&#34;
    adjacent = self.adjacent(qubit)
    return (Coupling(qubit, q) for q in adjacent)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pauliopt.topologies.TopologyDict"><code class="flex name class">
<span>class <span class="ident">TopologyDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The type of the dictionary returned by <code><a title="pauliopt.topologies.Topology.as_dict" href="#pauliopt.topologies.Topology.as_dict">Topology.as_dict</a></code>,
suitable for JSON serialization.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TopologyDict(TypedDict, total=True):
    &#34;&#34;&#34;
        The type of the dictionary returned by `Topology.as_dict`,
        suitable for JSON serialization.
    &#34;&#34;&#34;

    num_qubits: int
    &#34;&#34;&#34;
        Property exposing the number of qubits in the topology.
    &#34;&#34;&#34;

    couplings: List[List[int]]
    &#34;&#34;&#34;
        Property exposing the couplings between qubits in the topology.
    &#34;&#34;&#34;</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pauliopt.topologies.TopologyDict.couplings"><code class="name">var <span class="ident">couplings</span> : List[List[int]]</code></dt>
<dd>
<div class="desc"><p>Property exposing the couplings between qubits in the topology.</p></div>
</dd>
<dt id="pauliopt.topologies.TopologyDict.num_qubits"><code class="name">var <span class="ident">num_qubits</span> : int</code></dt>
<dd>
<div class="desc"><p>Property exposing the number of qubits in the topology.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pauliopt" href="index.html">pauliopt</a></code></li>
</ul>
</li>
<li><h3><a href="#header-variables">Global variables</a></h3>
<ul class="">
<li><code><a title="pauliopt.topologies.CouplingLike" href="#pauliopt.topologies.CouplingLike">CouplingLike</a></code></li>
<li><code><a title="pauliopt.topologies.Layouts" href="#pauliopt.topologies.Layouts">Layouts</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pauliopt.topologies.Coupling" href="#pauliopt.topologies.Coupling">Coupling</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.topologies.Coupling.as_pair" href="#pauliopt.topologies.Coupling.as_pair">as_pair</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.topologies.Matching" href="#pauliopt.topologies.Matching">Matching</a></code></h4>
<ul class="two-column">
<li><code><a title="pauliopt.topologies.Matching.flip" href="#pauliopt.topologies.Matching.flip">flip</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.flippable_couplings" href="#pauliopt.topologies.Matching.flippable_couplings">flippable_couplings</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.incident" href="#pauliopt.topologies.Matching.incident">incident</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.is_flippable" href="#pauliopt.topologies.Matching.is_flippable">is_flippable</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.matched_couplings" href="#pauliopt.topologies.Matching.matched_couplings">matched_couplings</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.matched_qubits" href="#pauliopt.topologies.Matching.matched_qubits">matched_qubits</a></code></li>
<li><code><a title="pauliopt.topologies.Matching.topology" href="#pauliopt.topologies.Matching.topology">topology</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.topologies.Topology" href="#pauliopt.topologies.Topology">Topology</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.topologies.Topology.adjacent" href="#pauliopt.topologies.Topology.adjacent">adjacent</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.as_dict" href="#pauliopt.topologies.Topology.as_dict">as_dict</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.available_nx_layouts" href="#pauliopt.topologies.Topology.available_nx_layouts">available_nx_layouts</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.complete" href="#pauliopt.topologies.Topology.complete">complete</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.couplings" href="#pauliopt.topologies.Topology.couplings">couplings</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.cycle" href="#pauliopt.topologies.Topology.cycle">cycle</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.dist" href="#pauliopt.topologies.Topology.dist">dist</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.draw" href="#pauliopt.topologies.Topology.draw">draw</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.from_dict" href="#pauliopt.topologies.Topology.from_dict">from_dict</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.from_qiskit_backend" href="#pauliopt.topologies.Topology.from_qiskit_backend">from_qiskit_backend</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.from_qiskit_config" href="#pauliopt.topologies.Topology.from_qiskit_config">from_qiskit_config</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.grid" href="#pauliopt.topologies.Topology.grid">grid</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.incident" href="#pauliopt.topologies.Topology.incident">incident</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.is_planar" href="#pauliopt.topologies.Topology.is_planar">is_planar</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.line" href="#pauliopt.topologies.Topology.line">line</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.num_qubits" href="#pauliopt.topologies.Topology.num_qubits">num_qubits</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.periodic_grid" href="#pauliopt.topologies.Topology.periodic_grid">periodic_grid</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.qubits" href="#pauliopt.topologies.Topology.qubits">qubits</a></code></li>
<li><code><a title="pauliopt.topologies.Topology.to_nx" href="#pauliopt.topologies.Topology.to_nx">to_nx</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pauliopt.topologies.TopologyDict" href="#pauliopt.topologies.TopologyDict">TopologyDict</a></code></h4>
<ul class="">
<li><code><a title="pauliopt.topologies.TopologyDict.couplings" href="#pauliopt.topologies.TopologyDict.couplings">couplings</a></code></li>
<li><code><a title="pauliopt.topologies.TopologyDict.num_qubits" href="#pauliopt.topologies.TopologyDict.num_qubits">num_qubits</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>